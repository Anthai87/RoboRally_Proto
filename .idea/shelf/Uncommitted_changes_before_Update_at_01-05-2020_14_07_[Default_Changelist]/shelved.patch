Index: src/main/java/dk/dtu/compute/se/pisd/roborally/dal/Connector.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\r\n *  This file is part of the initial project provided for the\r\n *  course \"Project in Software Development (02362)\" held at\r\n *  DTU Compute at the Technical University of Denmark.\r\n *\r\n *  Copyright (C) 2019, 2020: Ekkart Kindler, ekki@dtu.dk\r\n *\r\n *  This software is free software; you can redistribute it and/or modify\r\n *  it under the terms of the GNU General Public License as published by\r\n *  the Free Software Foundation; version 2 of the License.\r\n *\r\n *  This project is distributed in the hope that it will be useful,\r\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *  GNU General Public License for more details.\r\n *\r\n *  You should have received a copy of the GNU General Public License\r\n *  along with this project; if not, write to the Free Software\r\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\r\n *\r\n */\r\npackage dk.dtu.compute.se.pisd.roborally.dal;\r\n\r\nimport com.mysql.cj.util.StringUtils;\r\nimport dk.dtu.compute.se.pisd.roborally.fileaccess.IOUtil;\r\n\r\nimport java.sql.*;\r\n\r\n/**\r\n * ...\r\n *\r\n * @author Ekkart Kindler, ekki@dtu.dk\r\n *\r\n */\r\nclass Connector {\r\n\t\r\n    private static final String HOST     = \"localhost\";\r\n    private static final int    PORT     = 3306;\r\n    private static final String DATABASE = \"pisu\";\r\n    private static final String USERNAME = \"root\"; \r\n    private static final String PASSWORD = \"joontae2\";\r\n\r\n    private static final String DELIMITER = \";;\";\r\n    \r\n    private Connection connection;\r\n        \r\n    Connector() {\r\n        try {\r\n\t\t\t//String url = \"jdbc:mysql://\" + HOST + \":\" + PORT + \"/\" + DATABASE;\r\n\t\t\tString url = \"jdbc:mysql://\" + HOST + \":\" + PORT + \"/\" + DATABASE + \"?serverTimezone=UTC\";\r\n\t\t\tconnection = DriverManager.getConnection(url, USERNAME, PASSWORD);\r\n\r\n\t\t\tcreateDatabaseSchema();\r\n\t\t} catch (SQLException e) {\r\n\t\t\t// TODO we should try to diagnose and fix some problems here and\r\n\t\t\t//      exit in a more graceful way\r\n\t\t\te.printStackTrace();\r\n\t\t\t// Platform.exit();\r\n\t\t}\r\n    }\r\n    \r\n    private void createDatabaseSchema() {\r\n\r\n    \tString createTablesStatement =\r\n\t\t\t\tIOUtil.readResource(\"schemas/createschema.sql\");\r\n\r\n    \ttry {\r\n    \t\tconnection.setAutoCommit(false);\r\n    \t\tStatement statement = connection.createStatement();\r\n    \t\tfor (String sql : createTablesStatement.split(DELIMITER)) {\r\n    \t\t\tif (!StringUtils.isEmptyOrWhitespaceOnly(sql)) {\r\n    \t\t\t\tstatement.executeUpdate(sql);\r\n    \t\t\t}\r\n    \t\t}\r\n\r\n    \t\tstatement.close();\r\n    \t\tconnection.commit();\r\n    \t} catch (SQLException e) {\r\n    \t\te.printStackTrace();\r\n    \t\t// TODO error handling\r\n    \t\ttry {\r\n\t\t\t\tconnection.rollback();\r\n\t\t\t} catch (SQLException e1) {}\r\n    \t} finally {\r\n\t\t\ttry {\r\n\t\t\t\tconnection.setAutoCommit(true);\r\n\t\t\t} catch (SQLException e) {}\r\n\t\t}\r\n    }\r\n    \r\n    Connection getConnection() {\r\n    \treturn connection; \r\n    }\r\n    \r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/dk/dtu/compute/se/pisd/roborally/dal/Connector.java	(revision 0ae1f83f4ec7b7863e6c67875d965289e2843b06)
+++ src/main/java/dk/dtu/compute/se/pisd/roborally/dal/Connector.java	(date 1588082455349)
@@ -38,7 +38,7 @@
     private static final int    PORT     = 3306;
     private static final String DATABASE = "pisu";
     private static final String USERNAME = "root"; 
-    private static final String PASSWORD = "joontae2";
+    private static final String PASSWORD = "dinmor";
 
     private static final String DELIMITER = ";;";
     
Index: src/main/java/dk/dtu/compute/se/pisd/roborally/dal/Repository.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\r\n *  This file is part of the initial project provided for the\r\n *  course \"Project in Software Development (02362)\" held at\r\n *  DTU Compute at the Technical University of Denmark.\r\n *\r\n *  Copyright (C) 2019, 2020: Ekkart Kindler, ekki@dtu.dk\r\n *\r\n *  This software is free software; you can redistribute it and/or modify\r\n *  it under the terms of the GNU General Public License as published by\r\n *  the Free Software Foundation; version 2 of the License.\r\n *\r\n *  This project is distributed in the hope that it will be useful,\r\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *  GNU General Public License for more details.\r\n *\r\n *  You should have received a copy of the GNU General Public License\r\n *  along with this project; if not, write to the Free Software\r\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\r\n *\r\n */\r\npackage dk.dtu.compute.se.pisd.roborally.dal;\r\n\r\nimport com.mysql.cj.protocol.Resultset;\r\nimport dk.dtu.compute.se.pisd.roborally.fileaccess.LoadBoard;\r\nimport dk.dtu.compute.se.pisd.roborally.model.*;\r\nimport dk.dtu.compute.se.pisd.roborally.view.CardFieldView;\r\n\r\nimport java.sql.*;\r\nimport java.util.ArrayList;\r\nimport java.util.Date;\r\nimport java.util.List;\r\n\r\n/**\r\n * ...\r\n *\r\n * @author Ekkart Kindler, ekki@dtu.dk\r\n *\r\n */\r\nclass Repository implements IRepository {\r\n\t\r\n\tprivate static final String GAME_GAMEID = \"gameID\";\r\n\r\n\tprivate static final String GAME_NAME = \"name\";\r\n\t\r\n\tprivate static final String GAME_CURRENTPLAYER = \"currentPlayer\";\r\n\r\n\tprivate static final String GAME_PHASE = \"phase\";\r\n\r\n\tprivate static final String GAME_STEP = \"step\";\r\n\t\r\n\tprivate static final String PLAYER_PLAYERID = \"playerID\";\r\n\t\r\n\tprivate static final String PLAYER_NAME = \"name\";\r\n\r\n\tprivate static final String PLAYER_COLOUR = \"colour\";\r\n\t\r\n\tprivate static final String PLAYER_GAMEID = \"gameID\";\r\n\t\r\n\tprivate static final String PLAYER_POSITION_X = \"positionX\";\r\n\r\n\tprivate static final String PLAYER_POSITION_Y = \"positionY\";\r\n\r\n\tprivate static final String PLAYER_HEADING = \"heading\";\r\n\r\n\tprivate static final String FIELD_GAMEID = \"gameID\";\r\n\r\n\tprivate static final String FIELD_PLAYERID = \"playerID\";\r\n\r\n\tprivate static final String FIELD_TYPE = \"type\";\r\n\r\n\tprivate static final int  FIELD_TYPE_REGISTER = 1;\r\n\r\n\tprivate static final int  FIELD_TYPE_HAND = 0;\r\n\r\n\tprivate static final String FIELD_POS = \"position\";\r\n\r\n\tprivate static final String\tFIELD_VISIBLE = \"visible\";\r\n\r\n\tprivate static final String\tFIELD_COMMAND = \"command\";\r\n\r\n\r\n\r\n\tprivate Connector connector;\r\n\t\r\n\tRepository(Connector connector){\r\n\t\tthis.connector = connector;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic boolean createGameInDB(Board game) {\r\n\t\tif (game.getGameId() == null) {\r\n\t\t\tConnection connection = connector.getConnection();\r\n\t\t\ttry {\r\n\t\t\t\tconnection.setAutoCommit(false);\r\n\r\n\t\t\t\tPreparedStatement ps = getInsertGameStatementRGK();\r\n\t\t\t\t// TODO: the name should eventually set by the user\r\n\t\t\t\t//       for the game and should be then used\r\n\t\t\t\t//       game.getName();\r\n\t\t\t\t// Only if spare time is available\r\n\r\n\t\t\t\tps.setString(1, \"Date: \" +  new Date()); // instead of name\r\n\t\t\t\tps.setNull(2, Types.TINYINT); // game.getPlayerNumber(game.getCurrentPlayer())); is inserted after players!\r\n\t\t\t\tps.setInt(3, game.getPhase().ordinal());\r\n\t\t\t\tps.setInt(4, game.getStep());\r\n\r\n\t\t\t\t// If you have a foreign key constraint for current players,\r\n\t\t\t\t// the check would need to be temporarily disabled, since\r\n\t\t\t\t// MySQL does not have a per transaction validation, but\r\n\t\t\t\t// validates on a per row basis.\r\n\t\t\t\t// Statement statement = connection.createStatement();\r\n\t\t\t\t// statement.execute(\"SET foreign_key_checks = 0\");\r\n\r\n\t\t\t\tint affectedRows = ps.executeUpdate();\r\n\t\t\t\tResultSet generatedKeys = ps.getGeneratedKeys();\r\n\t\t\t\tif (affectedRows == 1 && generatedKeys.next()) {\r\n\t\t\t\t\tgame.setGameId(generatedKeys.getInt(1));\r\n\t\t\t\t}\r\n\t\t\t\tgeneratedKeys.close();\r\n\r\n\t\t\t\t// Enable foreign key constraint check again:\r\n\t\t\t\t// statement.execute(\"SET foreign_key_checks = 1\");\r\n\t\t\t\t// statement.close();\r\n\r\n\t\t\t\tcreatePlayersInDB(game);  // Look at line #276 \t- Reza\r\n\t\t\t\t/* TODO this method needs to be implemented first\r\n\t\t\t\t   createCardFieldsInDB(game);\r\n\t\t\t\t */\r\n\t\t\t\tcreateCardFieldsInDB(game);\r\n\r\n\t\t\t\t// since current player is a foreign key, it can oly be\r\n\t\t\t\t// inserted after the players are created, since MySQL does\r\n\t\t\t\t// not have a per transaction validation, but validates on\r\n\t\t\t\t// a per row basis.\r\n\t\t\t\tps = getSelectGameStatementU();\r\n\t\t\t\tps.setInt(1, game.getGameId());\r\n\r\n\t\t\t\tResultSet rs = ps.executeQuery();\r\n\t\t\t\tif (rs.next()) {\r\n\t\t\t\t\trs.updateInt(GAME_CURRENTPLAYER, game.getPlayerNumber(game.getCurrentPlayer()));\r\n\t\t\t\t\trs.updateRow();\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// TODO error handling\r\n\t\t\t\t}\r\n\t\t\t\trs.close();\r\n\r\n\t\t\t\tconnection.commit();\r\n\t\t\t\tconnection.setAutoCommit(true);\r\n\t\t\t\treturn true;\r\n\t\t\t} catch (SQLException e) {\r\n\t\t\t\t// TODO error handling\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t\tSystem.err.println(\"Some DB error\");\r\n\r\n\t\t\t\ttry {\r\n\t\t\t\t\tconnection.rollback();\r\n\t\t\t\t\tconnection.setAutoCommit(true);\r\n\t\t\t\t} catch (SQLException e1) {\r\n\t\t\t\t\t// TODO error handling\r\n\t\t\t\t\te1.printStackTrace();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tSystem.err.println(\"Game cannot be created in DB, since it has a game id already!\");\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t\t\r\n\t@Override\r\n\tpublic boolean updateGameInDB(Board game) {\r\n\t\tassert game.getGameId() != null;\r\n\t\t\r\n\t\tConnection connection = connector.getConnection();\r\n\t\ttry {\r\n\t\t\tconnection.setAutoCommit(false);\r\n\r\n\t\t\tPreparedStatement ps = getSelectGameStatementU();\r\n\t\t\tps.setInt(1, game.getGameId());\r\n\t\t\t\r\n\t\t\tResultSet rs = ps.executeQuery();\r\n\t\t\tif (rs.next()) {\r\n\t\t\t\trs.updateInt(GAME_CURRENTPLAYER, game.getPlayerNumber(game.getCurrentPlayer()));\r\n\t\t\t\trs.updateInt(GAME_PHASE, game.getPhase().ordinal());\r\n\t\t\t\trs.updateInt(GAME_STEP, game.getStep());\r\n\t\t\t\trs.updateRow();\r\n\t\t\t} else {\r\n\t\t\t\t// TODO error handling\r\n\t\t\t}\r\n\t\t\trs.close();\r\n\r\n\t\t\tupdatePlayersInDB(game);\r\n\r\n\t\t\t// TODO this method needs to be implemented first\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n            connection.commit();\r\n            connection.setAutoCommit(true);\r\n\t\t\treturn true;\r\n\t\t} catch (SQLException e) {\r\n\t\t\t// TODO error handling\r\n\t\t\te.printStackTrace();\r\n\t\t\tSystem.err.println(\"Some DB error\");\r\n\t\t\t\r\n\t\t\ttry {\r\n\t\t\t\tconnection.rollback();\r\n\t\t\t\tconnection.setAutoCommit(true);\r\n\t\t\t} catch (SQLException e1) {\r\n\t\t\t\t// TODO error handling\r\n\t\t\t\te1.printStackTrace();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/*private void updateCardFieldInDB(Board game) throws SQLException {\r\n\t\tPreparedStatement ps = getSelectCardFieldstatementU();\r\n\t\tps.setInt(1, game.getGameId());\r\n\r\n\t\tResultSet rs = ps.executeQuery();\r\n\t\twhile (rs.next()) {\r\n\t\t\tint fieldID = rs.getInt(FIELD_PLAYERID);\r\n;\t\t\tCommandCardField commandcard = new CommandCardField();\r\n\t\t\trs.updateInt(FIELD_VISIBLE, cardField.isVisible());\r\n\t\t\t// TODO error handling\r\n\t\t\t// TODO take care of case when number of players changes, etc\r\n\t\t\trs.updateRow();\r\n\t\t}\r\n\t\trs.close();\r\n\r\n\t\t// TODO error handling/consistency check: check whether all players were updated\r\n\t}\r\n\r\n\t */\r\n\t\r\n\t@Override\r\n\tpublic Board loadGameFromDB(int id) {\r\n\t\tBoard game;\r\n\t\ttry {\r\n\t\t\t// TODO here, we could actually use a simpler statement\r\n\t\t\t//      which is not updatable, but reuse the one from\r\n\t\t\t//      above for the pupose\r\n\t\t\tPreparedStatement ps = getSelectGameStatementU();\r\n\t\t\tps.setInt(1, id);\r\n\t\t\t\r\n\t\t\tResultSet rs = ps.executeQuery();\r\n\t\t\tint playerNo = -1;\r\n\t\t\tif (rs.next()) {\r\n\t\t\t\t// TODO the width and height could eventually come from the database\r\n\t\t\t\t// int width = AppController.BOARD_WIDTH;\r\n\t\t\t\t// int height = AppController.BOARD_HEIGHT;\r\n\t\t\t\t// game = new Board(width,height);\r\n\t\t\t\t// TODO and we should also store the used game board in the database\r\n\t\t\t\t//      for now, we use the default game board\r\n\t\t\t\tgame = LoadBoard.loadBoard(null);\r\n\t\t\t\tif (game == null) {\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\tplayerNo = rs.getInt(GAME_CURRENTPLAYER);\r\n\t\t\t\t// TODO currently we do not set the games name (needs to be added)\r\n\t\t\t\tgame.setPhase(Phase.values()[rs.getInt(GAME_PHASE)]);\r\n\t\t\t\tgame.setStep(rs.getInt(GAME_STEP));\r\n\t\t\t} else {\r\n\t\t\t\t// TODO error handling\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\trs.close();\r\n\r\n\t\t\tgame.setGameId(id);\t\t\t\r\n\t\t\tloadPlayersFromDB(game);\r\n\r\n\t\t\tif (playerNo >= 0 && playerNo < game.getPlayersNumber()) {\r\n\t\t\t\tgame.setCurrentPlayer(game.getPlayer(playerNo));\r\n\t\t\t} else {\r\n\t\t\t\t// TODO  error handling\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\tloadCardFieldsFromDB(game);\r\n\r\n\t\t\treturn game;\r\n\t\t} catch (SQLException e) {\r\n\t\t\t// TODO error handling\r\n\t\t\te.printStackTrace();\r\n\t\t\tSystem.err.println(\"Some DB error\");\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic List<GameInDB> getGames() {\r\n\t\t// TODO when there many games in the DB, fetching all available games\r\n\t\t//      from the DB is a bit extreme; eventually there should a\r\n\t\t//      methods that can filter the returned games in order to\r\n\t\t//      reduce the number of the returned games.\r\n\t\tList<GameInDB> result = new ArrayList<>();\r\n\t\ttry {\r\n\t\t\tPreparedStatement ps = getSelectGameIdsStatement();\r\n\t\t\tResultSet rs = ps.executeQuery();\r\n\t\t\twhile (rs.next()) {\r\n\t\t\t\tint id = rs.getInt(GAME_GAMEID);\r\n\t\t\t\tString name = rs.getString(GAME_NAME);\r\n\t\t\t\tresult.add(new GameInDB(id,name));\r\n\t\t\t}\r\n\t\t\trs.close();\r\n\t\t} catch (SQLException e) {\r\n\t\t\t// TODO proper error handling\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t\treturn result;\t\t\r\n\t}\r\n\r\n\tprivate void createCardFieldsInDB(Board game) throws SQLException {\r\n\t\tPreparedStatement ps = getSelectCardFieldStatementU();\r\n\t\tps.setInt(1, game.getGameId());\r\n\r\n\t\tResultSet rs = ps.executeQuery();\r\n\t\tfor (int i = 0; i < game.getPlayersNumber(); i++)\r\n\t\t{\r\n            for (int j = 0; j < Player.NO_REGISTERS ; j++) {\r\n                Player player\r\n\r\n\r\n\r\n\r\n\r\n\t\t\t}\r\n\r\n            for (int j = 0; j < Player.NO_CARDS; j++) {\r\n\t\t\t\tPlayer player = game.getPlayer(i);\r\n\t\t\t\trs.moveToInsertRow();\r\n\t\t\t\trs.updateInt(FIELD_GAMEID, game.getGameId());\r\n\t\t\t\trs.updateInt(FIELD_PLAYERID, i);\r\n\t\t\t\trs.updateInt(FIELD_TYPE, FIELD_TYPE_HAND);\r\n\t\t\t\trs.updateInt(FIELD_POS, j);\r\n\t\t\t\trs.updateInt(FIELD_COMMAND, player.getCardField(j).getCard().command.ordinal());\r\n\t\t\t\trs.insertRow();\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t}\r\n\r\n\t\trs.close();\r\n\t}\r\n\r\n\r\n\r\n\tprivate void createPlayersInDB(Board game) throws SQLException {\r\n\t\t// TODO code should be more defensive\r\n\t\tPreparedStatement ps = getSelectPlayersStatementU();\r\n\t\tps.setInt(1, game.getGameId());\r\n\t\t\r\n\t\tResultSet rs = ps.executeQuery();\r\n\t\tfor (int i = 0; i < game.getPlayersNumber(); i++) {\r\n\t\t\tPlayer player = game.getPlayer(i);\r\n\t\t\trs.moveToInsertRow();\r\n\t\t\trs.updateInt(PLAYER_GAMEID, game.getGameId());\r\n\t\t\trs.updateInt(PLAYER_PLAYERID, i);\r\n\t\t\trs.updateString(PLAYER_NAME, player.getName());\r\n\t\t\trs.updateString(PLAYER_COLOUR, player.getColor());\r\n\t\t\trs.updateInt(PLAYER_POSITION_X, player.getSpace().x);\r\n\t\t\trs.updateInt(PLAYER_POSITION_Y, player.getSpace().y);\r\n\t\t\trs.updateInt(PLAYER_HEADING, player.getHeading().ordinal());\r\n\t\t\trs.insertRow();\r\n\t\t}\r\n\r\n\t\trs.close();\r\n\t}\r\n\t\r\n\tprivate void loadPlayersFromDB(Board game) throws SQLException {\r\n\t\tPreparedStatement ps = getSelectPlayersASCStatement();\r\n\t\tps.setInt(1, game.getGameId());\r\n\t\t\r\n\t\tResultSet rs = ps.executeQuery();\r\n\t\tint i = 0;\r\n\t\twhile (rs.next()) {\r\n\t\t\tint playerId = rs.getInt(PLAYER_PLAYERID);\r\n\t\t\tif (i++ == playerId) {\r\n\t\t\t\t// TODO this should be more defensive\r\n\t\t\t\tString name = rs.getString(PLAYER_NAME);\r\n\t\t\t\tString colour = rs.getString(PLAYER_COLOUR);\r\n\t\t\t\tPlayer player = new Player(game, colour ,name,0);\r\n\t\t\t\tgame.addPlayer(player);\r\n\t\t\t\t\r\n\t\t\t\tint x = rs.getInt(PLAYER_POSITION_X);\r\n\t\t\t\tint y = rs.getInt(PLAYER_POSITION_Y);\r\n\t\t\t\tplayer.setSpace(game.getSpace(x,y));\r\n\t\t\t\tint heading = rs.getInt(PLAYER_HEADING);\r\n\t\t\t\tplayer.setHeading(Heading.values()[heading]);\r\n\r\n\t\t\t\t// TODO  should also load players program and hand here\r\n\t\t\t} else {\r\n\t\t\t\t// TODO error handling\r\n\t\t\t\tSystem.err.println(\"Game in DB does not have a player with id \" + i +\"!\");\r\n\t\t\t}\r\n\t\t}\r\n\t\trs.close();\r\n\t}\r\n\r\n\tprivate void loadCardFieldsFromDB (Board game) throws SQLException {\r\n\r\n\t\t\tPreparedStatement ps = getSelectCardFieldStatement();\r\n\t\t\tps.setInt( 1, game.getGameId());\r\n\r\n\t\t\tResultSet rs = ps.executeQuery();\r\n\t\t\twhile (rs.next()) {\r\n\t\t\tint playerId = rs.getInt(FIELD_PLAYERID);\r\n\t\t\tPlayer player = game.getPlayer(playerId);\r\n\t\t\tint type = rs.getInt(FIELD_TYPE);\r\n\t\t\tint pos = rs.getInt(FIELD_POS);\r\n\t\t\tCommandCardField field;\r\n\t\t\tif (type == FIELD_TYPE_REGISTER) {\r\n\t\t\t\tfield = player.getProgramField(pos);\r\n\t\t\t} else if (type == FIELD_TYPE_HAND) {\r\n\t\t\t\tfield = player.getCardField(pos);\r\n\t\t\t} else {\r\n\t\t\t\tfield = null;\r\n\t\t\t}\r\n\t\t\tif (field != null) {\r\n\t\t\t\tfield.setVisible(rs.getBoolean(FIELD_VISIBLE));\r\n\t\t\t\tObject c = rs.getObject(FIELD_COMMAND);\r\n\t\t\t\tif (c != null) {\r\n\t\t\t\t\tCommand card = Command.values() [rs.getInt(FIELD_COMMAND)];\r\n\t\t\t\t\tfield.setCard (new CommandCard(card));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t}\r\n\t\t\trs.close();\r\n}\r\n\r\n\r\n\r\n\tprivate void updatePlayersInDB(Board game) throws SQLException {\r\n\t\tPreparedStatement ps = getSelectPlayersStatementU();\r\n\t\tps.setInt(1, game.getGameId());\r\n\t\t\r\n\t\tResultSet rs = ps.executeQuery();\r\n\t\twhile (rs.next()) {\r\n\t\t\tint playerId = rs.getInt(PLAYER_PLAYERID);\r\n\t\t\t// TODO should be more defensive\r\n\t\t\tPlayer player = game.getPlayer(playerId);\r\n\t\t\t// rs.updateString(PLAYER_NAME, player.getName()); // not needed: player's names does not change\r\n\t\t\trs.updateInt(PLAYER_POSITION_X, player.getSpace().x);\r\n\t\t\trs.updateInt(PLAYER_POSITION_Y, player.getSpace().y);\r\n\t\t\trs.updateInt(PLAYER_HEADING, player.getHeading().ordinal());\r\n\t\t\t// TODO error handling\r\n\t\t\t// TODO take care of case when number of players changes, etc\r\n\t\t\trs.updateRow();\r\n\t\t}\r\n\t\trs.close();\r\n\t\t\r\n\t\t// TODO error handling/consistency check: check whether all players were updated\r\n\t}\r\n\r\n\tprivate static final String SQL_INSERT_GAME =\r\n\t\t\t\"INSERT INTO Game(name, currentPlayer, phase, step) VALUES (?, ?, ?, ?)\";\r\n\r\n\tprivate PreparedStatement insert_game_stmt = null;\r\n\r\n\tprivate PreparedStatement getInsertGameStatementRGK() {\r\n\t\tif (insert_game_stmt == null) {\r\n\t\t\tConnection connection = connector.getConnection();\r\n\t\t\ttry {\r\n\t\t\t\tinsert_game_stmt = connection.prepareStatement(\r\n\t\t\t\t\t\tSQL_INSERT_GAME,\r\n\t\t\t\t\t\tStatement.RETURN_GENERATED_KEYS);\r\n\t\t\t} catch (SQLException e) {\r\n\t\t\t\t// TODO error handling\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn insert_game_stmt;\r\n\t}\r\n\r\n\tprivate static final String SQL_SELECT_GAME =\r\n\t\t\t\"SELECT * FROM Game WHERE gameID = ?\";\r\n\t\r\n\tprivate PreparedStatement select_game_stmt = null;\r\n\t\r\n\tprivate PreparedStatement getSelectGameStatementU() {\r\n\t\tif (select_game_stmt == null) {\r\n\t\t\tConnection connection = connector.getConnection();\r\n\t\t\ttry {\r\n\t\t\t\tselect_game_stmt = connection.prepareStatement(\r\n\t\t\t\t\t\tSQL_SELECT_GAME,\r\n\t\t\t\t\t\tResultSet.TYPE_FORWARD_ONLY,\r\n\t\t\t\t\t    ResultSet.CONCUR_UPDATABLE);\r\n\t\t\t} catch (SQLException e) {\r\n\t\t\t\t// TODO error handling\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn select_game_stmt;\r\n\t}\r\n\t\t\r\n\tprivate static final String SQL_SELECT_PLAYERS =\r\n\t\t\t\"SELECT * FROM Player WHERE gameID = ?\";\r\n\r\n\tprivate PreparedStatement select_players_stmt = null;\r\n\r\n\tprivate PreparedStatement getSelectPlayersStatementU() {\r\n\t\tif (select_players_stmt == null) {\r\n\t\t\tConnection connection = connector.getConnection();\r\n\t\t\ttry {\r\n\t\t\t\tselect_players_stmt = connection.prepareStatement(\r\n\t\t\t\t\t\tSQL_SELECT_PLAYERS,\r\n\t\t\t\t\t\tResultSet.TYPE_FORWARD_ONLY,\r\n\t\t\t\t\t\tResultSet.CONCUR_UPDATABLE);\r\n\t\t\t} catch (SQLException e) {\r\n\t\t\t\t// TODO error handling\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn select_players_stmt;\t\t\t\t\t\t\t\t\t\t\t\t/////////////\r\n\t}\r\n\r\n\tprivate static final String SQL_SELECT_CARD_FIELDS = \"SELECT * FROM CardField WHERE gameID = ?\";\r\n\r\n\tprivate PreparedStatement select_card_field_stmt = null;\r\n\r\n\tprivate PreparedStatement getSelectCardFieldStatement() {\r\n\t\t\tif (select_card_field_stmt == null) {\r\n\t\t\t\t\tConnection connection = connector.getConnection();\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tselect_card_field_stmt = connection.prepareStatement(SQL_SELECT_CARD_FIELDS);\r\n\t\t\t\t\t\t\t} catch (SQLException e) {\r\n\t\t\t\t\t\t\t\t// TODO error handling\r\n\t\t\t\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn select_card_field_stmt;\r\n\t}\r\n\r\n\tprivate PreparedStatement select_card_field_stmt_u = null;\r\n\r\n\tprivate PreparedStatement getSelectCardFieldStatementU() {\r\n\t\tif (select_card_field_stmt_u == null) {\r\n\t\t\tConnection connection = connector.getConnection();\r\n\t\t\ttry {\r\n\t\t\t\tselect_card_field_stmt_u = connection.prepareStatement(\r\n\t\t\t\t\tSQL_SELECT_CARD_FIELDS,\r\n\t\t\t\t\tResultSet.TYPE_FORWARD_ONLY,\r\n\t\t\t\t\tResultSet.CONCUR_UPDATABLE);\r\n\t\t\t\t} catch (SQLException e){\r\n\t\t\t\t\t// TODO error handling\r\n\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn select_card_field_stmt_u;\r\n\t\t}\r\n\r\n\r\n\r\n\tprivate static final String SQL_SELECT_PLAYERS_ASC =\t\t\t\t\t\t/////////////\r\n\t\t\t\"SELECT * FROM Player WHERE gameID = ? ORDER BY playerID ASC\";\r\n\t\r\n\tprivate PreparedStatement select_players_asc_stmt = null;\r\n\t\r\n\tprivate PreparedStatement getSelectPlayersASCStatement() {\r\n\t\tif (select_players_asc_stmt == null) {\r\n\t\t\tConnection connection = connector.getConnection();\r\n\t\t\ttry {\r\n\t\t\t\t// This statement does not need to be updatable\r\n\t\t\t\tselect_players_asc_stmt = connection.prepareStatement(\r\n\t\t\t\t\t\tSQL_SELECT_PLAYERS_ASC);\r\n\t\t\t} catch (SQLException e) {\r\n\t\t\t\t// TODO error handling\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn select_players_asc_stmt;\r\n\t}\r\n\t\r\n\tprivate static final String SQL_SELECT_GAMES =\r\n\t\t\t\"SELECT gameID, name FROM Game\";\r\n\t\r\n\tprivate PreparedStatement select_games_stmt = null;\r\n\t\r\n\tprivate PreparedStatement getSelectGameIdsStatement() {\r\n\t\tif (select_games_stmt == null) {\r\n\t\t\tConnection connection = connector.getConnection();\r\n\t\t\ttry {\r\n\t\t\t\tselect_games_stmt = connection.prepareStatement(\r\n\t\t\t\t\t\tSQL_SELECT_GAMES);\r\n\t\t\t} catch (SQLException e) {\r\n\t\t\t\t// TODO error handling\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn select_games_stmt;\r\n\t}\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/dk/dtu/compute/se/pisd/roborally/dal/Repository.java	(revision 0ae1f83f4ec7b7863e6c67875d965289e2843b06)
+++ src/main/java/dk/dtu/compute/se/pisd/roborally/dal/Repository.java	(date 1588082863230)
@@ -326,7 +326,7 @@
 		for (int i = 0; i < game.getPlayersNumber(); i++)
 		{
             for (int j = 0; j < Player.NO_REGISTERS ; j++) {
-                Player player
+
 
 
 
